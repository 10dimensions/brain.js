{"version":3,"sources":["../../src/layer/pool.js"],"names":["predict","compare","Pool","padding","bias","filterWidth","filterHeight","settings","inputLayer","switchX","switchY","validate","predictKernel","output","width","height","depth","map","setSwitchX","setSwitchY","constants","inputWidth","inputHeight","paddingX","paddingY","compareKernel","outputWidth","outputHeight","weights","result","deltas","inputs","x","thread","y","largestValue","Infinity","largestX","largestY","filterY","inputY","filterX","inputX","input","z","value","Math","floor","deltaXIndex","deltaYIndex"],"mappings":"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","file":"pool.js","sourcesContent":["import { Filter } from './types';\nimport makeKernel from '../utilities/make-kernel';\nimport { setPadding } from '../utilities/layer-setup';\nexport default class Pool extends Filter {\n  static get defaults() {\n    return {\n      padding: 0,\n      bias: 0,\n      filterWidth: 0,\n      filterHeight: 0\n    };\n  }\n\n  constructor(settings, inputLayer) {\n    super(settings);\n    this.inputLayer = inputLayer;\n\n    setPadding(this, settings);\n\n    this.switchX = null;\n    this.switchY = null;\n    this.validate();\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width, this.height, this.depth],\n      map: {\n        switchX: setSwitchX,\n        switchY: setSwitchY\n      },\n      constants: {\n        inputWidth: this.inputLayer.width,\n        inputHeight: this.inputLayer.height,\n        paddingX: this.paddingX,\n        paddingY: this.paddingY,\n        filterHeight: this.filterHeight,\n        filterWidth: this.filterWidth\n      }\n    });\n\n    this.compareKernel = makeKernel(compare, {\n      output: [this.width, this.height, this.depth],\n      constants: {\n        outputWidth: this.width,\n        outputHeight: this.height,\n        paddingX: this.paddingX,\n        paddingY: this.paddingY\n      }\n    });\n  }\n\n  predict() {\n    const weights = this.predictKernel(this.inputLayer.weights);\n    this.switchX = weights.switchX;\n    this.switchY = weights.switchY;\n    return this.weights = weights.result;\n  }\n\n  compare() {\n    this.inputLayer.deltas = this.compareKernel(this.deltas, this.switchX, this.switchY);\n  }\n}\n\nexport function predict(inputs) {\n  const x = ((this.thread.x / this.output.x) * this.constants.inputWidth) - this.constants.paddingX;\n  const y = ((this.thread.y / this.output.y) * this.constants.inputHeight) - this.constants.paddingY;\n  let largestValue = -Infinity;\n  let largestX = -1;\n  let largestY = -1;\n\n  // convolve centered at this particular location\n  for (let filterY = 0; filterY < this.constants.filterHeight; filterY++) {\n    // coordinates in the original input array coordinates\n    let inputY = filterY + y;\n    for (let filterX = 0; filterX < this.constants.filterWidth; filterX++) {\n      let inputX = filterX + x;\n      if (\n        inputY >= 0\n        && inputY < this.constants.inputHeight\n        && inputX >= 0\n        && inputX < this.constants.inputWidth\n      ) {\n        const input = inputs[this.output.z][inputY][inputX];\n        if (input > largestValue) {\n          largestValue = input;\n          largestY = inputY;\n          largestX = inputX;\n        }\n      }\n    }\n  }\n  setSwitchY(largestY);\n  setSwitchX(largestX);\n  return largestValue;\n}\n\nfunction setSwitchY(value) {\n  return value;\n}\n\nfunction setSwitchX(value) {\n  return value;\n}\n\nexport function compare(deltas, switchY, switchX) {\n  const x = Math.floor(((this.thread.x / this.output.x) * this.constants.outputWidth) - this.constants.paddingX);\n  const y = Math.floor(((this.thread.y / this.output.y) * this.constants.outputHeight) - this.constants.paddingY);\n  const deltaXIndex = switchX[y][x];\n  const deltaYIndex = switchY[y][x];\n\n  if (deltaXIndex !== this.thread.y) return 0;\n  if (deltaYIndex !== this.thread.x) return 0;\n\n  return deltas[y][x];\n}\n"]}