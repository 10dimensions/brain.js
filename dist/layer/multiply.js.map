{"version":3,"sources":["../../src/layer/multiply.js"],"names":["predict","compareFromX","compareFromY","Multiply","inputLayer1","inputLayer2","compareKernel1","compareKernel2","width","height","validate","weights","deltas","Error","predictKernel","output","constants","size","layer","newDeltas1","newDeltas2","weights1","weights2","sum","i","thread","y","x","inputDeltas","inputWeights"],"mappings":"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","file":"multiply.js","sourcesContent":["import makeKernel from '../utilities/make-kernel';\nimport zeros2D from '../utilities/zeros-2d';\nimport { Operator } from './types';\n\nexport default class Multiply extends Operator {\n  constructor(inputLayer1, inputLayer2) {\n    super();\n    this.inputLayer1 = inputLayer1;\n    this.inputLayer2 = inputLayer2;\n    this.compareKernel1 = null;\n    this.compareKernel2 = null;\n\n    this.width = inputLayer2.width;\n    this.height = inputLayer1.height;\n    this.validate();\n    this.weights = zeros2D(this.width, this.height);\n    this.deltas = zeros2D(this.width, this.height);\n  }\n\n  validate() {\n    super.validate();\n    if (this.inputLayer1.width !== this.inputLayer2.height) {\n      throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`);\n    }\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width, this.height],\n      constants: {\n        size: this.inputLayer2.height\n      }\n    });\n    this.compareKernel1 = makeKernel(compareFromX, {\n      output: [this.inputLayer1.width, this.inputLayer1.height],\n      constants: {\n        size: this.inputLayer2.width\n      }\n    });\n    this.compareKernel2 = makeKernel(compareFromY, {\n      output: [this.inputLayer2.width, this.inputLayer2.height],\n      constants: {\n        size: this.inputLayer1.height\n      }\n    });\n  }\n  reuseKernels(layer) {\n    super.reuseKernels(layer);\n    this.compareKernel1 = layer.compareKernel1;\n    this.compareKernel2 = layer.compareKernel2;\n  }\n\n  predict() {\n    this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);\n  }\n\n  compare() {\n    const newDeltas1 = this.compareKernel1(this.deltas, this.inputLayer1.deltas, this.inputLayer2.weights);\n    const newDeltas2 = this.compareKernel2(this.deltas, this.inputLayer2.deltas, this.inputLayer1.weights);\n    this.inputLayer2.deltas = newDeltas2;\n    this.inputLayer1.deltas = newDeltas1;\n  }\n}\n\nexport function predict(weights1, weights2) {\n  let sum = 0;\n  for(let i = 0; i < this.constants.size; i++) {\n    sum += weights1[this.thread.y][i] * weights2[i][this.thread.x];\n  }\n  return sum;\n}\n\nexport function compareFromX(deltas, inputDeltas, inputWeights) {\n  let sum = inputDeltas[this.thread.y][this.thread.x];\n  for(let i = 0; i < this.constants.size; i++) {\n    sum += deltas[this.thread.y][i] * inputWeights[this.thread.x][i];\n  }\n  return sum;\n}\n\nexport function compareFromY(deltas, inputDeltas, inputWeights) {\n  let sum = inputDeltas[this.thread.y][this.thread.x];\n  for(let i = 0; i < this.constants.size; i++) {\n    sum += deltas[i][this.thread.x] * inputWeights[i][this.thread.y];\n  }\n  return sum;\n}"]}