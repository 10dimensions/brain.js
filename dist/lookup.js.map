{"version":3,"sources":["../src/lookup.js"],"names":["lookup","hashes","hash","reduce","memo","Object","assign","toHash","data","table","tableIndex","dataIndex","length","p","input","hasOwnProperty","output","index","i","object","arrayLength","array","Float32Array","z","inputTable","outputTable","convertInput","getTypedArrayFn","convertOutput","map","datum","value","buffer","ArrayBuffer","Array","isArray","v","from","keys"],"mappings":";;;;;;;;;;AAAA;IACqBA,M;;;;;;;;AACnB;;;;;4BAKeC,M,EAAQ;AACrB,UAAMC,OAAOD,OAAOE,MAAP,CAAc,UAACC,IAAD,EAAOF,IAAP,EAAgB;AACzC,eAAOG,OAAOC,MAAP,CAAcF,IAAd,EAAoBF,IAApB,CAAP;AACD,OAFY,EAEV,EAFU,CAAb;;AAIA,aAAOF,OAAOO,MAAP,CAAcL,IAAd,CAAP;AACD;;;iCAEmBM,I,EAAM;AACxB,UAAMC,QAAQ,EAAd;AACA,UAAIC,aAAa,CAAjB;AACA,WAAK,IAAIC,YAAY,CAArB,EAAwBA,YAAYH,KAAKI,MAAzC,EAAiDD,WAAjD,EAA8D;AAC5D,aAAK,IAAIE,CAAT,IAAcL,KAAKG,SAAL,EAAgBG,KAA9B,EAAqC;AACnC,cAAI,CAACL,MAAMM,cAAN,CAAqBF,CAArB,CAAL,EAA8B;AAC5BJ,kBAAMI,CAAN,IAAWH,YAAX;AACD;AACF;AACF;AACD,aAAOD,KAAP;AACD;;;kCAEoBD,I,EAAM;AACzB,UAAMC,QAAQ,EAAd;AACA,UAAIC,aAAa,CAAjB;AACA,WAAK,IAAIC,YAAY,CAArB,EAAwBA,YAAYH,KAAKI,MAAzC,EAAiDD,WAAjD,EAA8D;AAC5D,aAAK,IAAIE,CAAT,IAAcL,KAAKG,SAAL,EAAgBK,MAA9B,EAAsC;AACpC,cAAI,CAACP,MAAMM,cAAN,CAAqBF,CAArB,CAAL,EAA8B;AAC5BJ,kBAAMI,CAAN,IAAWH,YAAX;AACD;AACF;AACF;AACD,aAAOD,KAAP;AACD;;AAED;;;;;;;;2BAKcP,I,EAAM;AAClB,UAAIF,SAAS,EAAb;AACA,UAAIiB,QAAQ,CAAZ;AACA,WAAK,IAAIC,CAAT,IAAchB,IAAd,EAAoB;AAClBF,eAAOkB,CAAP,IAAYD,OAAZ;AACD;AACD,aAAOjB,MAAP;AACD;;AAED;;;;;;;;;;4BAOeA,M,EAAQmB,M,EAAQC,W,EAAa;AAC1C,UAAMC,QAAQ,IAAIC,YAAJ,CAAiBF,WAAjB,CAAd;AACA,WAAK,IAAIF,CAAT,IAAclB,MAAd,EAAsB;AACpBqB,cAAMrB,OAAOkB,CAAP,CAAN,IAAmBC,OAAOD,CAAP,KAAa,CAAhC;AACD;AACD,aAAOG,KAAP;AACD;;AAED;;;;;;;;;6BAMgBrB,M,EAAQqB,K,EAAO;AAC7B,UAAInB,OAAO,EAAX;AACA,WAAK,IAAIgB,CAAT,IAAclB,MAAd,EAAsB;AACpBE,aAAKgB,CAAL,IAAUG,MAAMrB,OAAOkB,CAAP,CAAN,CAAV;AACD;AACD,aAAOhB,IAAP;AACD;;AAED;;;;;;;;oCAKuBmB,K,EAAO;AAC5B,UAAIrB,SAAS,EAAb;AACA,UAAIuB,IAAI,CAAR;AACA,UAAIL,IAAIG,MAAMT,MAAd;AACA,aAAOM,MAAM,CAAb,EAAgB;AACdlB,eAAOqB,MAAMH,CAAN,CAAP,IAAmBK,GAAnB;AACD;AACD,aAAOvB,MAAP;AACD;;;mCAEqBQ,I,EAAMgB,U,EAAYC,W,EAAa;AACnD;AACA,UAAMC,eAAeC,gBAAgBnB,KAAK,CAAL,EAAQM,KAAxB,EAA+BU,UAA/B,CAArB;AACA,UAAMI,gBAAgBD,gBAAgBnB,KAAK,CAAL,EAAQQ,MAAxB,EAAgCS,WAAhC,CAAtB;;AAEA,UAAIC,gBAAgBE,aAApB,EAAmC;AACjCpB,eAAOA,KAAKqB,GAAL,CAAS,iBAAS;AACvB,iBAAO;AACLf,mBAAOY,aAAaI,MAAMhB,KAAnB,CADF;AAELE,oBAAQY,cAAcE,MAAMd,MAApB;AAFH,WAAP;AAID,SALM,CAAP;AAMD,OAPD,MAOO,IAAIU,YAAJ,EAAkB;AACvBlB,eAAOA,KAAKqB,GAAL,CAAS,iBAAS;AACvB,iBAAO;AACLf,mBAAOY,aAAaI,MAAMhB,KAAnB,CADF;AAELE,oBAAQc,MAAMd;AAFT,WAAP;AAID,SALM,CAAP;AAMD,OAPM,MAOA,IAAIY,aAAJ,EAAmB;AACxBpB,eAAOA,KAAKqB,GAAL,CAAS,iBAAS;AACvB,iBAAO;AACLf,mBAAOgB,MAAMhB,KADR;AAELE,oBAAQY,cAAcE,MAAMd,MAApB;AAFH,WAAP;AAID,SALM,CAAP;AAMD;AACD,aAAOR,IAAP;AACD;;;;;;kBA9HkBR,M;;;AAiIrB,SAAS2B,eAAT,CAAyBI,KAAzB,EAAgCtB,KAAhC,EAAuC;AACrC,MAAIsB,MAAMC,MAAN,YAAwBC,WAA5B,EAAyC;AACvC,WAAO,IAAP;AACD,GAFD,MAEO,IAAIC,MAAMC,OAAN,CAAcJ,KAAd,CAAJ,EAA0B;AAC/B,WAAO,UAACK,CAAD;AAAA,aAAOd,aAAae,IAAb,CAAkBD,CAAlB,CAAP;AAAA,KAAP;AACD,GAFM,MAEA;AACL,QAAMxB,SAASP,OAAOiC,IAAP,CAAY7B,KAAZ,EAAmBG,MAAlC;AACA,WAAO,UAACwB,CAAD,EAAO;AACZ,UAAMf,QAAQ,IAAIC,YAAJ,CAAiBV,MAAjB,CAAd;AACA,WAAK,IAAIM,CAAT,IAAcT,KAAd,EAAqB;AACnBY,cAAMZ,MAAMS,CAAN,CAAN,IAAkBkB,EAAElB,CAAF,KAAQ,CAA1B;AACD;AACD,aAAOG,KAAP;AACD,KAND;AAOD;AACF","file":"lookup.js","sourcesContent":["/* Functions for turning sparse hashes into arrays and vice versa */\nexport default class lookup {\n  /**\n   * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`\n   * @param {Object} hashes\n   * @returns {Object}\n   */\n  static toTable(hashes) {\n    const hash = hashes.reduce((memo, hash) => {\n      return Object.assign(memo, hash);\n    }, {});\n\n    return lookup.toHash(hash);\n  }\n\n  static toInputTable(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      for (let p in data[dataIndex].input) {\n        if (!table.hasOwnProperty(p)) {\n          table[p] = tableIndex++;\n        }\n      }\n    }\n    return table;\n  }\n\n  static toOutputTable(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      for (let p in data[dataIndex].output) {\n        if (!table.hasOwnProperty(p)) {\n          table[p] = tableIndex++;\n        }\n      }\n    }\n    return table;\n  }\n\n  /**\n   * performs `{a: 6, b: 7} -> {a: 0, b: 1}`\n   * @param {Object} hash\n   * @returns {Object}\n   */\n  static toHash(hash) {\n    let lookup = {};\n    let index = 0;\n    for (let i in hash) {\n      lookup[i] = index++;\n    }\n    return lookup;\n  }\n\n  /**\n   * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`\n   * @param {*} lookup\n   * @param {*} object\n   * @param {*} arrayLength\n   * @returns {Float32Array}\n   */\n  static toArray(lookup, object, arrayLength) {\n    const array = new Float32Array(arrayLength);\n    for (let i in lookup) {\n      array[lookup[i]] = object[i] || 0;\n    }\n    return array;\n  }\n\n  /**\n   * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`\n   * @param {Object} lookup\n   * @param {Array} array\n   * @returns {Object}\n   */\n  static toObject(lookup, array) {\n    let hash = {};\n    for (let i in lookup) {\n      hash[i] = array[lookup[i]];\n    }\n    return hash;\n  }\n\n  /**\n   *\n   * @param {Array} array\n   * @returns {*}\n   */\n  static lookupFromArray(array) {\n    let lookup = {};\n    let z = 0;\n    let i = array.length;\n    while (i-- > 0) {\n      lookup[array[i]] = z++;\n    }\n    return lookup;\n  }\n\n  static toTrainingData(data, inputTable, outputTable) {\n    // turn sparse hash input into arrays with 0s as filler\n    const convertInput = getTypedArrayFn(data[0].input, inputTable);\n    const convertOutput = getTypedArrayFn(data[0].output, outputTable);\n\n    if (convertInput && convertOutput) {\n      data = data.map(datum => {\n        return {\n          input: convertInput(datum.input),\n          output: convertOutput(datum.output),\n        };\n      });\n    } else if (convertInput) {\n      data = data.map(datum => {\n        return {\n          input: convertInput(datum.input),\n          output: datum.output\n        };\n      });\n    } else if (convertOutput) {\n      data = data.map(datum => {\n        return {\n          input: datum.input,\n          output: convertOutput(datum.output)\n        };\n      });\n    }\n    return data;\n  }\n}\n\nfunction getTypedArrayFn(value, table) {\n  if (value.buffer instanceof ArrayBuffer) {\n    return null;\n  } else if (Array.isArray(value)) {\n    return (v) => Float32Array.from(v);\n  } else {\n    const length = Object.keys(table).length;\n    return (v) => {\n      const array = new Float32Array(length);\n      for (let i in table) {\n        array[table[i]] = v[i] || 0;\n      }\n      return array;\n    }\n  }\n}"]}