{"version":3,"sources":["../../src/layer/lstm.js"],"names":["settings","recurrentInput","input","height","inputGateWeights","width","inputGatePeepholes","inputGateBias","inputGate","forgetGateWeights","forgetGatePeepholes","forgetGateBias","forgetGate","outputGateWeights","outputGatePeepholes","outputGateBias","outputGate","memoryWeights","memoryPeepholes","memoryBias","memory","retainCell","writeCell","cell"],"mappings":";;;;;;AAAA;;kBAUe,UAACA,QAAD,EAAWC,cAAX,EAA2BC,KAA3B,EAAqC;AAAA,MAC1CC,MAD0C,GAC/BH,QAD+B,CAC1CG,MAD0C;;AAElD,MAAMC,mBAAmB,mBAAO,EAAED,cAAF,EAAUE,OAAOH,MAAMC,MAAvB,EAAP,CAAzB;AACA,MAAMG,qBAAqB,mBAAO,EAAED,OAAOF,MAAT,EAAiBA,cAAjB,EAAP,CAA3B;AACA,MAAMI,gBAAgB,kBAAM,EAAEJ,cAAF,EAAN,CAAtB;AACA,MAAMK,YAAY,oBAChB,gBACE,gBACE,qBACEJ,gBADF,EAEEF,KAFF,CADF,EAKE,qBACEI,kBADF,EAEEL,cAFF,CALF,CADF,EAWEM,aAXF,CADgB,CAAlB;;AAgBA,MAAME,oBAAoB,mBAAO,EAAEN,cAAF,EAAUE,OAAOH,MAAMC,MAAvB,EAAP,CAA1B;AACA,MAAMO,sBAAsB,mBAAO,EAAEL,OAAOF,MAAT,EAAiBA,cAAjB,EAAP,CAA5B;AACA,MAAMQ,iBAAiB,kBAAM,EAAER,cAAF,EAAN,CAAvB;AACA,MAAMS,aAAa,oBACjB,gBACE,gBACE,qBACEH,iBADF,EAEEP,KAFF,CADF,EAKE,qBACEQ,mBADF,EAEET,cAFF,CALF,CADF,EAWEU,cAXF,CADiB,CAAnB;;AAgBA,MAAME,oBAAoB,mBAAO,EAAEV,cAAF,EAAUE,OAAOH,MAAMC,MAAvB,EAAP,CAA1B;AACA,MAAMW,sBAAsB,mBAAO,EAAET,OAAOF,MAAT,EAAiBA,cAAjB,EAAP,CAA5B;AACA,MAAMY,iBAAiB,kBAAM,EAAEZ,cAAF,EAAN,CAAvB;AACA,MAAMa,aAAa,oBACjB,gBACE,gBACE,qBACEH,iBADF,EAEEX,KAFF,CADF,EAKE,qBACEY,mBADF,EAEEb,cAFF,CALF,CADF,EAWEc,cAXF,CADiB,CAAnB;;AAgBA,MAAME,gBAAgB,mBAAO,EAAEd,cAAF,EAAUE,OAAOH,MAAMC,MAAvB,EAAP,CAAtB;AACA,MAAMe,kBAAkB,mBAAO,EAAEb,OAAOF,MAAT,EAAiBA,cAAjB,EAAP,CAAxB;AACA,MAAMgB,aAAa,kBAAM,EAAEhB,cAAF,EAAN,CAAnB;AACA,MAAMiB,SAAS,iBACb,gBACE,gBACE,qBACEH,aADF,EAEEf,KAFF,CADF,EAKE,qBACEgB,eADF,EAEEjB,cAFF,CALF,CADF,EAWEkB,UAXF,CADa,CAAf;;AAgBA;AACA,MAAME,aAAa,4BAAgBT,UAAhB,EAA4BV,KAA5B,CAAnB,CA/EkD,CA+EK;AACvD,MAAMoB,YAAY,4BAAgBd,SAAhB,EAA2BY,MAA3B,CAAlB,CAhFkD,CAgFI;AACtD,MAAMG,OAAO,gBAAIF,UAAJ,EAAgBC,SAAhB,CAAb,CAjFkD,CAiFT;;AAEzC;AACA,SAAO,4BACLN,UADK,EAEL,iBAAKO,IAAL,CAFK,CAAP;AAID,C","file":"lstm.js","sourcesContent":["import {\n  add,\n  multiply,\n  multiplyElement,\n  random,\n  sigmoid,\n  tanh,\n  zeros\n} from './index';\n\nexport default (settings, recurrentInput, input) => {\n  const { height } = settings;\n  const inputGateWeights = random({ height, width: input.height });\n  const inputGatePeepholes = random({ width: height, height });\n  const inputGateBias = zeros({ height });\n  const inputGate = sigmoid(\n    add(\n      add(\n        multiply(\n          inputGateWeights,\n          input\n        ),\n        multiply(\n          inputGatePeepholes,\n          recurrentInput\n        )\n      ),\n      inputGateBias\n    )\n  );\n\n  const forgetGateWeights = random({ height, width: input.height });\n  const forgetGatePeepholes = random({ width: height, height });\n  const forgetGateBias = zeros({ height });\n  const forgetGate = sigmoid(\n    add(\n      add(\n        multiply(\n          forgetGateWeights,\n          input\n        ),\n        multiply(\n          forgetGatePeepholes,\n          recurrentInput\n        )\n      ),\n      forgetGateBias\n    )\n  );\n\n  const outputGateWeights = random({ height, width: input.height });\n  const outputGatePeepholes = random({ width: height, height });\n  const outputGateBias = zeros({ height });\n  const outputGate = sigmoid(\n    add(\n      add(\n        multiply(\n          outputGateWeights,\n          input\n        ),\n        multiply(\n          outputGatePeepholes,\n          recurrentInput\n        )\n      ),\n      outputGateBias\n    )\n  );\n\n  const memoryWeights = random({ height, width: input.height });\n  const memoryPeepholes = random({ width: height, height });\n  const memoryBias = zeros({ height });\n  const memory = tanh(\n    add(\n      add(\n        multiply(\n          memoryWeights,\n          input\n        ),\n        multiply(\n          memoryPeepholes,\n          recurrentInput\n        )\n      ),\n      memoryBias\n    )\n  );\n\n  // compute new cell activation\n  const retainCell = multiplyElement(forgetGate, input); // what do we keep from cell\n  const writeCell = multiplyElement(inputGate, memory); // what do we write to cell\n  const cell = add(retainCell, writeCell); // new cell contents\n\n  // compute hidden state as gated, saturated cell activations\n  return multiplyElement(\n    outputGate,\n    tanh(cell)\n  );\n}"]}