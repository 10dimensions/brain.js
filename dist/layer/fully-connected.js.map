{"version":3,"sources":["../../src/layer/fully-connected.js"],"names":["predict","learnInputs","learnFilters","learnBiases","FullyConnected","settings","inputLayer","depth","Error","learnInputsKernel","learnFiltersKernel","learnBiasKernel","width","height","validate","predictKernel","output","constants","inputDepth","inputHeight","inputWidth","learnBiasesKernel","learnKernel","filters","deltas","outputs","biases","weights","filterDeltas","bias","inputs","y","x","thread","filterDelta"],"mappings":"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","file":"fully-connected.js","sourcesContent":["import { Filter } from './types';\nimport makeKernel from '../utilities/make-kernel';\n\nexport default class FullyConnected extends Filter {\n  constructor(settings, inputLayer) {\n    super(settings);\n\n    if (this.inputLayer.depth !== 1) {\n      //TODO: make go away and handle 3d, should be fairly easy\n      throw new Error('depth of 1 only supported at this time');\n    }\n\n    this.inputLayer = inputLayer;\n    this.learnInputsKernel = null;\n    this.learnFiltersKernel = null;\n    this.learnBiasKernel = null;\n\n    const { width, height, depth } = inputLayer;\n    this.width = width * height * depth;\n    this.validate();\n  }\n\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnInputsKernel = makeKernel(learnInputs, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnFiltersKernel = makeKernel(learnFilters, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnBiasesKernel = makeKernel(learnBiases, {\n      output: [this.width],\n      constants: {\n        inputDepth: this.inputLayer.depth,\n        inputHeight: this.inputLayer.height,\n        inputWidth: this.inputLayer.width\n      }\n    });\n\n    this.learnKernel = () => {\n      this.learnInputsKernel(this.filters, this.deltas);\n      this.learnFiltersKernel(this.inputLayer.outputs, this.deltas);\n      this.learnBiasKernel(this.biases, this.deltas);\n    };\n  }\n\n  predict() {\n    this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);\n  }\n\n  compare() {\n    this.filterDeltas = this.learnFilters(this.inputLayer, this.deltas);\n    this.biases = this.learnBiasesKernel(this.bias, this.deltas);\n    this.deltas = this.learnInputs(this.filters);\n  }\n}\n\nexport function predict(inputs, filters, biases) {\n  let output = 0;\n  for (let y = 0; y < this.constants.inputHeight; y++) {\n    for (let x = 0; x < this.constants.inputWidth; x++) {\n      output += inputs[y][x] * filters[y][x];\n    }\n  }\n  return output + biases[this.thread.x];\n}\n\nexport function learnInputs(filters, weights) {\n  let filterDelta = 0;\n  for (let y = 0; y < this.constants.inputWidth; y++) {\n    filterDelta += filters[this.thread.x][y] * weights[this.thread.x];\n  }\n  return filterDelta;\n}\n\nexport function learnFilters(inputs, weights) {\n  //0 here should probably be depth\n  return inputs[0][this.thread.y] * weights[this.thread.x];\n}\n\nexport function learnBiases(biases, deltas) {\n  return biases[this.output.x] * deltas[this.output.x];\n}"]}