{"version":3,"sources":["../../src/layer/leaky-relu.js"],"names":["predict","compare","LeakyRelu","inputLayer","width","height","depth","validate","predictKernel","functions","compareKernel","weights","deltas","inputs","thread","y","x"],"mappings":";;;;;;;;QAiCgBA,O,GAAAA,O;QAIAC,O,GAAAA,O;;AArChB;;AACA;;;;AACA;;;;;;;;;;IAEqBC,S;;;AACnB,qBAAYC,UAAZ,EAAwB;AAAA;;AAAA;;AAEtB,UAAKA,UAAL,GAAkBA,UAAlB;AAFsB,QAGdC,KAHc,GAGWD,UAHX,CAGdC,KAHc;AAAA,QAGPC,MAHO,GAGWF,UAHX,CAGPE,MAHO;AAAA,QAGCC,KAHD,GAGWH,UAHX,CAGCG,KAHD;;AAItB,UAAKF,KAAL,GAAaA,KAAb;AACA,UAAKC,MAAL,GAAcA,MAAd;AACA,UAAKC,KAAL,GAAaA,KAAb;AACA,UAAKC,QAAL;AAPsB;AAQvB;;;;mCACc;AACb,WAAKC,aAAL,GAAqB,0BAAWR,OAAX,EAAoB;AACvCS,mBAAW;AAD4B,OAApB,CAArB;;AAIA,WAAKC,aAAL,GAAqB,0BAAWT,OAAX,EAAoB;AACvCQ,mBAAW;AAD4B,OAApB,CAArB;AAGD;;;8BAES;AACR,WAAKE,OAAL,GAAe,KAAKH,aAAL,CAAmB,KAAKL,UAAL,CAAgBQ,OAAnC,CAAf;AACD;;;8BAES;AACR,WAAKC,MAAL,GAAc,KAAKF,aAAL,CAAmB,KAAKC,OAAxB,EAAiC,KAAKC,MAAtC,CAAd;AACD;;;;;;kBA1BkBV,S;AA6Bd,SAASF,OAAT,CAAiBa,MAAjB,EAAyB;AAC9B,SAAO,yBAASA,OAAO,KAAKC,MAAL,CAAYC,CAAnB,EAAsB,KAAKD,MAAL,CAAYE,CAAlC,CAAT,CAAP;AACD;;AAEM,SAASf,OAAT,CAAiBU,OAAjB,EAA0BC,MAA1B,EAAkC;AACvC,SAAO,wBAAQD,QAAQ,KAAKG,MAAL,CAAYC,CAApB,EAAuB,KAAKD,MAAL,CAAYE,CAAnC,CAAR,EAA+CJ,OAAO,KAAKE,MAAL,CAAYC,CAAnB,EAAsB,KAAKD,MAAL,CAAYE,CAAlC,CAA/C,CAAP;AACD","file":"leaky-relu.js","sourcesContent":["import { Activation } from './types';\nimport makeKernel from '../utilities/make-kernel';\nimport { activate, measure } from '../activation/leaky-relu';\n\nexport default class LeakyRelu extends Activation {\n  constructor(inputLayer) {\n    super();\n    this.inputLayer = inputLayer;\n    const { width, height, depth } = inputLayer;\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.validate();\n  }\n  setupKernels() {\n    this.predictKernel = makeKernel(predict, {\n      functions: [activate]\n    });\n\n    this.compareKernel = makeKernel(compare, {\n      functions: [measure]\n    });\n  }\n\n  predict() {\n    this.weights = this.predictKernel(this.inputLayer.weights);\n  }\n\n  compare() {\n    this.deltas = this.compareKernel(this.weights, this.deltas);\n  }\n}\n\nexport function predict(inputs) {\n  return activate(inputs[this.thread.y][this.thread.x]);\n}\n\nexport function compare(weights, deltas) {\n  return measure(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);\n}"]}