{"version":3,"sources":["../../../src/recurrent/matrix/multiply.js"],"names":["multiply","getMultiplyList","multiplyOptimized","cachedOptimizedLists","performance","require","product","left","right","start","now","leftRows","rows","leftColumns","columns","rightColumns","leftWeights","weights","rightWeights","productWeights","leftDeltas","deltas","rightDeltas","leftRow","leftRowBase","rightRowBase","rightColumn","dot","leftColumn","rightColumnBase","leftIndex","rightIndex","end","console","log","cachedKey","list","push","length","fill","i","lookup"],"mappings":"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","file":"multiply.js","sourcesContent":["const cachedOptimizedLists = {};\nconst performance = require('perf_hooks').performance;\n\n/**\n * multiply {left} and {right} matrix weights to {into}\n * @param {Matrix} product\n * @param {Matrix} left\n * @param {Matrix} right\n */\nexport default function multiply(product, left, right) {\n  const start = performance.now();\n  const leftRows = left.rows;\n  const leftColumns = left.columns;\n  const rightColumns = right.columns;\n  const leftWeights = left.weights;\n  const rightWeights = right.weights;\n  const productWeights = product.weights;\n  const leftDeltas = left.deltas;\n  const rightDeltas = right.deltas;\n\n  // loop over rows of left\n  for(let leftRow = 0; leftRow < leftRows; leftRow++) {\n    const leftRowBase = leftColumns * leftRow;\n    const rightRowBase = rightColumns * leftRow;\n    // loop over cols of right\n    for(let rightColumn = 0; rightColumn < rightColumns; rightColumn++) {\n\n      // dot product loop\n      let dot = 0;\n      //loop over columns of left\n      for(let leftColumn = 0; leftColumn < leftColumns; leftColumn++) {\n        const rightColumnBase = rightColumns * leftColumn;\n        const leftIndex = leftRowBase + leftColumn;\n        const rightIndex = rightColumnBase + rightColumn;\n        dot +=\n            leftWeights[leftIndex]\n          * rightWeights[rightIndex];\n        leftDeltas[leftIndex] = 0;\n        rightDeltas[rightIndex] = 0;\n      }\n      productWeights[rightRowBase + rightColumn] = dot;\n    }\n  }\n  const end = performance.now();\n  console.log(`not optimized product${product.rows}x${product.columns} left${left.rows}x${left.columns} right${right.rows}x${right.columns}: ${(end - start)}`);\n}\n\n/**\n * build list for multiply {left} and {right} matrix weights to {into}\n * @param {Matrix} product\n * @param {Matrix} left\n * @param {Matrix} right\n */\nexport function getMultiplyList(product, left, right) {\n  const cachedKey = `product${product.rows}x${product.columns}left${left.rows}x${left.columns}right${right.rows}x${right.columns}`;\n  if (cachedOptimizedLists[cachedKey]) {\n    return cachedOptimizedLists[cachedKey];\n  }\n  const list = cachedOptimizedLists[cachedKey] = [];\n  const leftRows = left.rows;\n  const leftColumns = left.columns;\n  const rightColumns = right.columns;\n\n  // loop over rows of left\n  for(let leftRow = 0; leftRow < leftRows; leftRow++) {\n    const leftRowBase = leftColumns * leftRow;\n    const rightRowBase = rightColumns * leftRow;\n    // loop over cols of right\n    for(let rightColumn = 0; rightColumn < rightColumns; rightColumn++) {\n      //loop over columns of left\n      for(let leftColumn = 0; leftColumn < leftColumns; leftColumn++) {\n        const rightColumnBase = rightColumns * leftColumn;\n        const leftIndex = leftRowBase + leftColumn;\n        const rightIndex = rightColumnBase + rightColumn;\n        list.push({ product: rightRowBase + rightColumn, left: leftIndex, right: rightIndex });\n      }\n    }\n  }\n  console.log(list.length);\n  return list;\n}\n\nexport function multiplyOptimized(product, left, right, list) {\n  const start = performance.now();\n  const leftWeights = left.weights;\n  const rightWeights = right.weights;\n  const productWeights = product.weights;\n  const leftDeltas = left.deltas;\n  const rightDeltas = right.deltas;\n  product.weights.fill(0);\n  for (let i = 0; i < list.length; i++) {\n    const lookup = list[i];\n    productWeights[lookup.product] += leftWeights[lookup.left] * rightWeights[lookup.right];\n    leftDeltas[lookup.left] = 0;\n    rightDeltas[lookup.right] = 0;\n  }\n  const end = performance.now();\n  console.log(`optimized product${product.rows}x${product.columns} left${left.rows}x${left.columns} right${right.rows}x${right.columns}: ${(end - start)}`);\n}\n"]}